class PlayerBall{
	int radius;
	color col;
	PVector pos;
	PVector dir;

	PlayerBall(int r, color c, PVector p, PVector d, float s){
		this.radius = r;
		this.col = c;
		this.pos = p;
		this.dir = d.normalize();
	}
	
	PVector GetPosition(){
		return pos.copy();
	}

	int GetRadius(){
		return radius;
	}

	void MovePos(float deltaT){
		
	}

	void Restrict(int maxRoomX, int maxRoomY){
		//Restrict room
		if(this.pos.x <= this.radius){
			this.dir.x *= -1;
		}else if(this.pos.x >= maxRoomX - this.radius){
			this.dir.x *=-1;
		}

		if(this.pos.y <= this.radius){
			this.dir.y *= -1;
		}else if(this.pos.y > maxRoomY - this.radius){
			this.dir.y *= -1;
		}
	}

	void CheckCollision(PVector posOther, float rOther){
		float minDist = radius + rOther;
		minDist *= minDist;

		PVector dirBetween = posOther.sub(pos);

		//Optimized???????
		if(dirBetween.x > minDist && dirBetween.y > minDist){
			return;
		}

		float  distBetween = dirBetween.magSq();

		if(distBetween < minDist){
			this.col = color(255,255,0,255);
			print("dist ", distBetween, "\n");
			this.dir = dirBetween.normalize();
			this.dir.mult(-1);
		}
	}

	void ControllBall(PVector inputAxis, float maxSpeed, float accTime, float deAccTime, float turnSpeed, float deltaTime){
		if(inputAxis.magSq() != 0){
			speed += deltaTime * accTime;
			if(speed > 1){
				speed = 1;
			}

			dir.set(lerp(dir.x, inputAxis.x, turnSpeed * deltaTime), lerp(dir.y, inputAxis.y, turnSpeed * deltaTime));
		}else{
			speed -= deltaTime * deAccTime;
			if(speed < 0){
				speed = 0;
			}
		}

		PVector d = dir.copy();
		d.mult(speed * deltaT);
		pos.add(d);
	}

	void DrawBall(){
		noStroke();
		fill(col);
		ellipse(pos.x, pos.y, radius*2, radius*2);
	}
}